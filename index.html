<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>èµ›åšè€ƒå¤ï¼šä¸‰æ˜Ÿå †æ•°å­—é—äº§ç²’å­ç³»ç»Ÿ</title>

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Google Fonts -->
    <link
        href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@300;500;700&family=Orbitron:wght@400;700&display=swap"
        rel="stylesheet">

    <!-- Three.js & Dependencies -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <!-- MediaPipe -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"
        crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"
        crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        body {
            background-color: #000406;
            margin: 0;
            overflow: hidden;
            font-family: 'Noto Serif SC', serif;
            color: #e2e8f0;
        }

        /* Custom Scrollbar for Glass Panels */
        ::-webkit-scrollbar {
            width: 6px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(20, 184, 166, 0.4);
            border-radius: 3px;
        }

        .glass-panel {
            background: rgba(255, 255, 255, 0.03);
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
            border: 1px solid rgba(255, 255, 255, 0.08);
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.5);
        }

        .tech-font {
            font-family: 'Orbitron', sans-serif;
        }

        #loading-overlay {
            transition: opacity 0.5s ease;
        }

        .glow-text {
            text-shadow: 0 0 10px rgba(45, 212, 191, 0.6);
        }

        /* Progress Ring */
        .progress-ring__circle {
            transition: stroke-dashoffset 0.1s;
            transform: rotate(-90deg);
            transform-origin: 50% 50%;
        }
    </style>
</head>

<body class="antialiased selection:bg-cyan-500 selection:text-black">

    <!-- 3D Canvas Container -->
    <div id="canvas-container" class="absolute inset-0 z-0"></div>

    <!-- UI: Header -->
    <header class="absolute top-0 left-0 w-full p-6 z-10 flex justify-between items-center pointer-events-none">
        <div class="pointer-events-auto">
            <h1
                class="text-3xl font-bold tracking-widest text-transparent bg-clip-text bg-gradient-to-r from-yellow-500 to-cyan-400 glow-text">
                SANXINGDUI <span class="text-sm font-light text-cyan-200 block tech-font opacity-80">DIGITAL HERITAGE
                    ARCHIVE</span>
            </h1>
        </div>
        <div class="glass-panel px-4 py-2 rounded-full flex items-center gap-2 pointer-events-auto">
            <div class="w-2 h-2 rounded-full bg-green-500 animate-pulse"></div>
            <span class="text-xs text-cyan-100 tech-font">SYSTEM ONLINE â€¢ 60 FPS</span>
        </div>
    </header>

    <!-- UI: Sidebar (Controls & Upload) -->
    <aside class="absolute left-6 top-32 w-80 z-10 flex flex-col gap-4 pointer-events-none">

        <!-- Upload Control -->
        <div class="glass-panel p-6 rounded-2xl pointer-events-auto transform transition hover:scale-105 duration-300">
            <h2 class="text-lg font-bold text-yellow-500 mb-2 border-b border-white/10 pb-2">æ•°æ®æºæ¥å…¥</h2>
            <label class="block mb-4">
                <span class="sr-only">Choose file</span>
                <input type="file" id="obj-input" accept=".obj" class="block w-full text-sm text-slate-400
                  file:mr-4 file:py-2 file:px-4
                  file:rounded-full file:border-0
                  file:text-sm file:font-semibold
                  file:bg-cyan-900/50 file:text-cyan-400
                  hover:file:bg-cyan-900/80 cursor-pointer
                " />
            </label>
            <p class="text-xs text-slate-500">æ”¯æŒæ ¼å¼: .OBJ (æ— éœ€è´´å›¾)<br>ç³»ç»Ÿå°†è‡ªåŠ¨è¿›è¡Œç²’å­åŒ–é‡æ„ã€‚</p>
        </div>

        <!-- AI Description Panel -->
        <div class="glass-panel p-6 rounded-2xl pointer-events-auto h-96 flex flex-col">
            <div class="flex justify-between items-center mb-3">
                <h2 class="text-lg font-bold text-cyan-400">AI è€ƒå¤ç¬”è®°</h2>
                <svg class="w-5 h-5 text-yellow-500 animate-spin hidden" id="ai-loading" fill="none"
                    viewBox="0 0 24 24">
                    <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                    <path class="opacity-75" fill="currentColor"
                        d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z">
                    </path>
                </svg>
            </div>
            <div id="ai-content" class="text-sm leading-relaxed text-slate-300 overflow-y-auto pr-2 h-full font-light">
                <p class="italic text-slate-500">æ­£åœ¨ç­‰å¾…æ–‡ç‰©æ•°æ®åŠ è½½...</p>
                <p class="mt-4 text-xs text-slate-600 border-l-2 border-cyan-800 pl-3">
                    æ“ä½œæŒ‡å—ï¼š<br>
                    1. è½¬åŠ¨æ‰‹æŒï¼šæ—‹è½¬æ–‡ç‰©<br>
                    2. æåˆæ‰‹æŒ‡ï¼šç¼©æ”¾<br>
                    3. ğŸ‘æ‰‹åŠ¿ï¼šç¡®è®¤/åˆ†æ
                </p>
            </div>
        </div>
    </aside>

    <!-- UI: Camera & Interaction Feedback -->
    <div
        class="absolute bottom-6 right-6 w-64 h-48 z-10 glass-panel rounded-xl overflow-hidden pointer-events-auto shadow-2xl shadow-cyan-900/20">
        <video id="input-video"
            class="absolute inset-0 w-full h-full object-cover transform -scale-x-100 opacity-60 mix-blend-screen"></video>
        <canvas id="output-canvas" class="absolute inset-0 w-full h-full transform -scale-x-100"></canvas>

        <!-- Status Overlay -->
        <div class="absolute bottom-2 left-2 right-2 flex justify-between items-end">
            <span id="gesture-label"
                class="text-xs font-bold bg-black/50 px-2 py-1 rounded text-cyan-400 tech-font">DETECTING...</span>

            <!-- SVG Progress for Thumbs Up Gesture -->
            <div class="relative w-10 h-10">
                <svg class="w-full h-full" viewBox="0 0 100 100">
                    <circle class="text-gray-700 stroke-current" stroke-width="8" cx="50" cy="50" r="40"
                        fill="transparent"></circle>
                    <circle id="progress-ring" class="text-yellow-500 progress-ring__circle stroke-current"
                        stroke-width="8" stroke-linecap="round" cx="50" cy="50" r="40" fill="transparent"
                        stroke-dasharray="251.2" stroke-dashoffset="251.2"></circle>
                </svg>
                <div class="absolute inset-0 flex items-center justify-center">
                    <span class="text-[14px] font-bold text-white">ğŸ‘</span>
                </div>
            </div>
        </div>
    </div>

    <!-- Loading Screen -->
    <div id="loading-overlay" class="fixed inset-0 bg-black z-50 flex flex-col items-center justify-center text-center">
        <div class="w-16 h-16 border-4 border-cyan-900 border-t-yellow-500 rounded-full animate-spin mb-4"></div>
        <h2 class="text-xl text-cyan-500 tracking-widest tech-font">INITIALIZING SYSTEM</h2>
        <p class="text-sm text-slate-500 mt-2">Connecting to Neural Interface...</p>
    </div>

    <!-- Scripts -->
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { OBJLoader } from 'three/addons/loaders/OBJLoader.js';
        import { MeshSurfaceSampler } from 'three/addons/math/MeshSurfaceSampler.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';

        // --- Global Config ---
        const CONFIG = {
            particleCount: 150000, // Reduced slightly for better stability on average GPUs
            bg: 0x000406,
            colors: {
                cyan: new THREE.Color('#06b6d4'),
                gold: new THREE.Color('#fbbf24'),
                dark: new THREE.Color('#000000')
            },
            cameraZ: 150
        };

        // --- Gemini API Setup ---
        const apiKey = ""; // Provided by runtime environment

        async function getArtifactDescription(filename) {
            if (!apiKey) {
                return "Gemini API key is missing. Simulation mode active.";
            }

            const prompt = `
            ä½ æ˜¯ä¸€ä½ç ”ç©¶å¤èœ€æ–‡æ˜ä¸ä¸‰æ˜Ÿå †çš„èµ„æ·±è€ƒå¤å­¦å®¶ã€‚
            ç”¨æˆ·æ­£åœ¨æŸ¥çœ‹ä¸€ä¸ªåä¸º "${filename}" çš„3Dæ•°å­—æ–‡ç‰©ã€‚
            è¯·ç”¨åšå­¦ã€è¯—æ„ä¸”ç¥ç§˜çš„è¯­è¨€ï¼Œå†™ä¸€æ®µç®€çŸ­çš„è§£è¯´è¯ï¼ˆ150å­—ä»¥å†…ï¼‰ã€‚
            ç»“åˆ"ç¥­ç¥€"ã€"ç¥æƒ"ã€"é’é“œæ—¶ä»£"ã€"çºµç›®"ç­‰å…ƒç´ ã€‚
            é£æ ¼è¦æ·±é‚ƒï¼Œä»¿ä½›è·¨è¶Šä¸‰åƒå¹´çš„å¯¹è¯ã€‚
            ä¸è¦åŒ…å«Markdownæ ¼å¼ï¼Œç›´æ¥è¾“å‡ºçº¯æ–‡æœ¬ã€‚
            `;

            try {
                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        contents: [{ parts: [{ text: prompt }] }]
                    })
                });

                const data = await response.json();
                return data.candidates[0].content.parts[0].text;
            } catch (error) {
                console.error("Gemini Error:", error);
                return "æ•°æ®è¿æ¥ä¸­æ–­ã€‚æ— æ³•æ£€ç´¢å¤èœ€æ–‡æ˜æ•°æ®åº“ã€‚è¯·æ£€æŸ¥ç½‘ç»œè¿æ¥æˆ–APIé…ç½®ã€‚";
            }
        }

        // --- Three.js Setup ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(CONFIG.bg, 0.002);
        scene.background = new THREE.Color(CONFIG.bg);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = CONFIG.cameraZ;
        camera.position.y = 20;

        const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        container.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.5;
        controls.enableZoom = true;

        // --- Post Processing (Bloom) ---
        const renderScene = new RenderPass(scene, camera);
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0.15; // æé«˜é–¾å€¼ï¼Œæ¸›å°‘èƒŒæ™¯æ³›å…‰
        bloomPass.strength = 0.6;   // é™ä½å¼·åº¦ (åŸç‚º 1.2)
        bloomPass.radius = 0.5;

        const composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        // --- Particle System (Shader) ---

        // Vertex Shader: Morphs from random noise (Chaos) to target shape (Order)
        const vertexShader = `
            uniform float uTime;
            uniform float uMorphFactor; // 0.0 = Chaos, 1.0 = Artifact
            uniform float uScale;
            
            attribute vec3 aTarget;
            attribute float aSize;
            attribute float aRandom;
            
            varying vec3 vColor;
            varying float vAlpha;

            // Simplex noise function (simplified)
            vec3 curlNoise(vec3 p) {
                return vec3(sin(p.y*0.1 + uTime), cos(p.z*0.1 + uTime*0.5), sin(p.x*0.1));
            }

            void main() {
                // Chaos state: Floating nebula
                vec3 noisePos = position + curlNoise(position + uTime * 0.2) * 20.0;
                
                // Artifact state: The loaded OBJ vertices
                vec3 targetPos = aTarget * uScale;
                
                // Add subtle floating to the artifact state too
                targetPos += curlNoise(targetPos * 2.0 + uTime * 0.1) * 0.5;

                // Interpolate
                vec3 finalPos = mix(noisePos, targetPos, uMorphFactor);

                // Rotate based on time for the chaos part only? No, global rotation handles main view
                
                vec4 mvPosition = modelViewMatrix * vec4(finalPos, 1.0);
                gl_Position = projectionMatrix * mvPosition;

                // Size attenuation
                gl_PointSize = (aSize * 2.0 + (1.0 - uMorphFactor) * 3.0) * (300.0 / -mvPosition.z);

                // Color logic
                // Chaos = Cyan/Blue, Artifact = Gold/Bronze
                vec3 colorChaos = vec3(0.0, 0.8, 1.0); // Cyan
                vec3 colorArtifact = vec3(1.0, 0.7, 0.1); // Gold
                
                // Gradient based on Y position for depth
                float heightMix = smoothstep(-20.0, 20.0, finalPos.y);
                vec3 mixedColor = mix(colorChaos, colorArtifact, uMorphFactor);
                mixedColor = mix(mixedColor, vec3(0.0, 1.0, 0.8), heightMix * 0.3); // Add gradients

                vColor = mixedColor;
                vAlpha = 0.3 + uMorphFactor * 0.4; // é™ä½åŸºç¤é€æ˜åº¦ (åŸç‚º 0.6)
            }
        `;

        const fragmentShader = `
            varying vec3 vColor;
            varying float vAlpha;

            void main() {
                // Circular particle
                vec2 xy = gl_PointCoord.xy - vec2(0.5);
                float ll = length(xy);
                if(ll > 0.5) discard;

                // Soft edge
                float strength = 1.0 - (ll * 2.0);
                strength = pow(strength, 1.5);

                gl_FragColor = vec4(vColor, vAlpha * strength);
            }
        `;

        // Initialize Geometry
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(CONFIG.particleCount * 3);
        const targets = new Float32Array(CONFIG.particleCount * 3);
        const sizes = new Float32Array(CONFIG.particleCount);
        const randoms = new Float32Array(CONFIG.particleCount);

        for (let i = 0; i < CONFIG.particleCount; i++) {
            // Initial Chaos positions (Sphere cloud)
            const r = 80 * Math.cbrt(Math.random());
            const theta = Math.random() * 2 * Math.PI;
            const phi = Math.acos(2 * Math.random() - 1);

            positions[i * 3] = r * Math.sin(phi) * Math.cos(theta);
            positions[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta);
            positions[i * 3 + 2] = r * Math.cos(phi);

            // Default Target: A Torus Knot shape as a placeholder
            // We'll calculate this properly later, but init with chaos
            targets[i * 3] = positions[i * 3];
            targets[i * 3 + 1] = positions[i * 3 + 1];
            targets[i * 3 + 2] = positions[i * 3 + 2];

            sizes[i] = Math.random();
            randoms[i] = Math.random();
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('aTarget', new THREE.BufferAttribute(targets, 3));
        geometry.setAttribute('aSize', new THREE.BufferAttribute(sizes, 1));
        geometry.setAttribute('aRandom', new THREE.BufferAttribute(randoms, 1));

        const material = new THREE.ShaderMaterial({
            uniforms: {
                uTime: { value: 0 },
                uMorphFactor: { value: 0.0 },
                uScale: { value: 1.0 }
            },
            vertexShader: vertexShader,
            fragmentShader: fragmentShader,
            transparent: true,
            depthWrite: false,
            blending: THREE.AdditiveBlending
        });

        const particleSystem = new THREE.Points(geometry, material);
        scene.add(particleSystem);

        // --- Logic: Load Default Shape ---
        function generateTorusKnotPoints() {
            const tempGeo = new THREE.TorusKnotGeometry(20, 6, 150, 20);
            const sampler = new MeshSurfaceSampler(new THREE.Mesh(tempGeo)).build();
            const tempPos = new THREE.Vector3();
            const targetAttr = geometry.attributes.aTarget;

            for (let i = 0; i < CONFIG.particleCount; i++) {
                sampler.sample(tempPos);
                targetAttr.setXYZ(i, tempPos.x, tempPos.y, tempPos.z);
            }
            targetAttr.needsUpdate = true;

            // Animate morph
            animateMorph(1.0);
            updateAIDescription("æœªçŸ¥ç¥å™¨ (Torus Knot Protocol)");
        }

        // --- Logic: OBJ Loading ---
        const objLoader = new OBJLoader();
        const objInput = document.getElementById('obj-input');

        objInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function (evt) {
                const contents = evt.target.result;
                const object = objLoader.parse(contents);

                // Process Mesh
                let mesh = null;
                object.traverse((child) => {
                    if (child.isMesh && !mesh) mesh = child;
                });

                if (mesh) {
                    processMeshToParticles(mesh);
                    updateAIDescription(file.name);
                }
            };
            reader.readAsText(file);
        });

        function processMeshToParticles(mesh) {
            // Reset Morph to 0 (Chaos) briefly
            material.uniforms.uMorphFactor.value = 0;

            // 1. Center and Normalize Scale
            mesh.geometry.computeBoundingBox();
            const center = new THREE.Vector3();
            mesh.geometry.boundingBox.getCenter(center);
            mesh.geometry.translate(-center.x, -center.y, -center.z);

            const size = new THREE.Vector3();
            mesh.geometry.boundingBox.getSize(size);
            const maxDim = Math.max(size.x, size.y, size.z);
            const scaleFactor = 40.0 / maxDim;
            mesh.geometry.scale(scaleFactor, scaleFactor, scaleFactor);

            // 2. Sample Points
            const sampler = new MeshSurfaceSampler(mesh).build();
            const tempPos = new THREE.Vector3();
            const targetAttr = geometry.attributes.aTarget;

            for (let i = 0; i < CONFIG.particleCount; i++) {
                sampler.sample(tempPos);
                targetAttr.setXYZ(i, tempPos.x, tempPos.y, tempPos.z);
            }
            targetAttr.needsUpdate = true;

            // 3. Animate Morph
            setTimeout(() => {
                animateMorph(1.0);
            }, 500);
        }

        function animateMorph(targetValue) {
            const start = material.uniforms.uMorphFactor.value;
            const duration = 2000;
            const startTime = performance.now();

            function update() {
                const elapsed = performance.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                // Ease out cubic
                const ease = 1 - Math.pow(1 - progress, 3);

                material.uniforms.uMorphFactor.value = start + (targetValue - start) * ease;

                if (progress < 1) requestAnimationFrame(update);
            }
            update();
        }

        async function updateAIDescription(name) {
            const aiContent = document.getElementById('ai-content');
            const loading = document.getElementById('ai-loading');

            loading.classList.remove('hidden');
            aiContent.innerHTML = `<p class="italic text-slate-500">æ­£åœ¨åˆ†ææ–‡ç‰©ç»“æ„æ•°æ® [${name}]...</p>`;

            const desc = await getArtifactDescription(name);

            // Typewriter effect
            aiContent.innerHTML = '';
            loading.classList.add('hidden');

            let i = 0;
            const speed = 30;
            function typeWriter() {
                if (i < desc.length) {
                    aiContent.innerHTML += desc.charAt(i);
                    i++;
                    setTimeout(typeWriter, speed);
                    // Scroll to bottom
                    aiContent.scrollTop = aiContent.scrollHeight;
                }
            }
            typeWriter();
        }

        // --- MediaPipe Hands Logic ---
        const videoElement = document.getElementById('input-video');
        const canvasElement = document.getElementById('output-canvas');
        const canvasCtx = canvasElement.getContext('2d');
        const gestureLabel = document.getElementById('gesture-label');
        const progressRing = document.getElementById('progress-ring');

        // Progress Ring Calc
        const radius = progressRing.r.baseVal.value;
        const circumference = radius * 2 * Math.PI;
        progressRing.style.strokeDasharray = `${circumference} ${circumference}`;
        progressRing.style.strokeDashoffset = circumference;

        let goodGestureStartTime = 0;
        const GOOD_HOLD_TIME = 1500; // 1.5s
        let isHoldingGood = false;
        
        // Hand rotation tracking
        let previousHandAngle = null;
        const ROTATION_SENSITIVITY = 2.0; // Multiplier for rotation speed

        function onResults(results) {
            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);

            let detectedGesture = "NONE";

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];

                // Draw skeleton
                drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, { color: '#06b6d4', lineWidth: 2 });
                drawLandmarks(canvasCtx, landmarks, { color: '#fbbf24', lineWidth: 1, radius: 3 });

                // --- Interaction Logic ---

                // 1. Rotation (Hand Rotation Gesture Detection)
                // Calculate hand rotation angle using wrist (0) to middle finger MCP (9)
                const wrist = landmarks[0];
                const middleMCP = landmarks[9]; // Middle finger base knuckle
                
                // Calculate angle of the hand (in radians)
                const deltaX = middleMCP.x - wrist.x;
                const deltaY = middleMCP.y - wrist.y;
                const currentHandAngle = Math.atan2(deltaY, deltaX);
                
                if (previousHandAngle !== null) {
                    // Calculate angle difference
                    let angleDiff = currentHandAngle - previousHandAngle;
                    
                    // Normalize angle difference to -PI to PI range
                    if (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
                    if (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
                    
                    // Apply rotation to particle system
                    // Positive to match hand rotation direction
                    particleSystem.rotation.y += angleDiff * ROTATION_SENSITIVITY;
                }
                
                // Store current angle for next frame
                previousHandAngle = currentHandAngle;

                // 2. Pinch to Scale (Thumb Tip 4, Index Tip 8)
                const thumbTip = landmarks[4];
                const indexTip = landmarks[8];
                const distance = Math.sqrt(
                    Math.pow(thumbTip.x - indexTip.x, 2) +
                    Math.pow(thumbTip.y - indexTip.y, 2)
                );

                // Distance usually 0.05 (closed) to 0.3 (open)
                // Map to scale 0.5 to 2.0
                if (distance > 0.05) {
                    const targetScale = 0.5 + (distance * 4.0);
                    const currentScale = material.uniforms.uScale.value;
                    material.uniforms.uScale.value += (targetScale - currentScale) * 0.1;
                }

                // 3. Thumbs Up (Good) Gesture Detection
                // Thumb extended upward, other fingers curled
                const thumbTipForGesture = landmarks[4];
                const thumbIP = landmarks[3]; // Thumb interphalangeal joint
                const thumbMCP = landmarks[2]; // Thumb metacarpophalangeal joint
                const indexMCP = landmarks[5]; // Index finger MCP
                const middleTip = landmarks[12];
                const ringTip = landmarks[16];
                const pinkyTip = landmarks[20];
                const wristForGesture = landmarks[0];
                
                // Check if thumb is extended upward
                // Thumb tip should be significantly above thumb MCP
                const thumbExtended = thumbTipForGesture.y < thumbMCP.y - 0.1;
                
                // Check if other fingers are curled (tips close to palm/MCP joints)
                const indexCurled = Math.abs(indexTip.y - indexMCP.y) < 0.15;
                const middleCurled = middleTip.y > wristForGesture.y - 0.1; // Tip not far from wrist
                const ringCurled = ringTip.y > wristForGesture.y - 0.1;
                const pinkyCurled = pinkyTip.y > wristForGesture.y - 0.1;
                
                const isThumbsUp = thumbExtended && indexCurled && middleCurled && ringCurled && pinkyCurled;

                if (isThumbsUp) {
                    detectedGesture = "GOOD DETECTED";
                    if (!isHoldingGood) {
                        isHoldingGood = true;
                        goodGestureStartTime = performance.now();
                    } else {
                        // Update Progress Ring
                        const elapsed = performance.now() - goodGestureStartTime;
                        const progress = Math.min(elapsed / GOOD_HOLD_TIME, 1);
                        const offset = circumference - progress * circumference;
                        progressRing.style.strokeDashoffset = offset;

                        if (elapsed >= GOOD_HOLD_TIME) {
                            detectedGesture = "CONFIRMED";
                            triggerGoodAction();
                            goodGestureStartTime = performance.now(); // Reset to prevent spam
                        }
                    }
                } else {
                    isHoldingGood = false;
                    progressRing.style.strokeDashoffset = circumference;
                }
            } else {
                // Auto rotate if no hand
                particleSystem.rotation.y += 0.002;
                // Reset hand angle tracking
                previousHandAngle = null;
            }

            gestureLabel.innerText = detectedGesture;
            canvasCtx.restore();
        }

        function triggerGoodAction() {
            // Visual feedback
            material.uniforms.uMorphFactor.value = 0.5; // Brief flash to chaos
            setTimeout(() => {
                animateMorph(1.0);
            }, 300);

            // Re-generate description for current item as a "Refined Scan"
            updateAIDescription("æ·±åº¦æ‰«æ - é‡æ–°æ ¡å‡†");
        }

        const hands = new Hands({
            locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
            }
        });

        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults(onResults);

        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({ image: videoElement });
            },
            width: 320,
            height: 240
        });
        cameraUtils.start();

        // --- Window Resize ---
        window.addEventListener('resize', onWindowResize, false);
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
            material.uniforms.uResolution?.value.set(window.innerWidth, window.innerHeight);
        }

        // --- Animation Loop ---
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);

            const elapsedTime = clock.getElapsedTime();
            material.uniforms.uTime.value = elapsedTime;

            controls.update(); // only needed if autoRotate or damping

            // Render Bloom
            composer.render();
        }

        // --- Init ---
        // Hide loading screen after 1.5s
        setTimeout(() => {
            document.getElementById('loading-overlay').style.opacity = '0';
            setTimeout(() => {
                document.getElementById('loading-overlay').style.display = 'none';
                generateTorusKnotPoints(); // Start with default
            }, 500);
        }, 1500);

        animate();

    </script>
</body>

</html>