<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>赛博考古：三星堆数字遗产粒子系统</title>

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Google Fonts -->
    <link
        href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@300;500;700&family=Orbitron:wght@400;700&display=swap"
        rel="stylesheet">

    <!-- Three.js & Dependencies -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <!-- MediaPipe -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"
        crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"
        crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        body {
            background-color: #000406;
            margin: 0;
            overflow: hidden;
            font-family: 'Noto Serif SC', serif;
            color: #e2e8f0;
        }

        /* Custom Scrollbar for Glass Panels */
        ::-webkit-scrollbar {
            width: 6px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(20, 184, 166, 0.4);
            border-radius: 3px;
        }

        .glass-panel {
            background: rgba(255, 255, 255, 0.03);
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
            border: 1px solid rgba(255, 255, 255, 0.08);
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.5);
        }

        .tech-font {
            font-family: 'Orbitron', sans-serif;
        }

        #loading-overlay {
            transition: opacity 0.5s ease;
        }

        .glow-text {
            text-shadow: 0 0 10px rgba(45, 212, 191, 0.6);
        }

        /* Progress Ring */
        .progress-ring__circle {
            transition: stroke-dashoffset 0.1s;
            transform: rotate(-90deg);
            transform-origin: 50% 50%;
        }
    </style>
</head>

<body class="antialiased selection:bg-cyan-500 selection:text-black">

    <!-- 3D Canvas Container -->
    <div id="canvas-container" class="absolute inset-0 z-0"></div>

    <!-- UI: Header -->
    <header class="absolute top-0 left-0 w-full p-6 z-10 flex justify-between items-center pointer-events-none">
        <div class="pointer-events-auto">
            <h1
                class="text-3xl font-bold tracking-widest text-transparent bg-clip-text bg-gradient-to-r from-yellow-500 to-cyan-400 glow-text">
                SANXINGDUI <span class="text-sm font-light text-cyan-200 block tech-font opacity-80">DIGITAL HERITAGE
                    ARCHIVE</span>
            </h1>
        </div>
        <div class="glass-panel px-4 py-2 rounded-full flex items-center gap-2 pointer-events-auto">
            <div class="w-2 h-2 rounded-full bg-green-500 animate-pulse"></div>
            <span class="text-xs text-cyan-100 tech-font">SYSTEM ONLINE • 60 FPS</span>
        </div>
    </header>

    <!-- UI: Sidebar (Controls & Upload) -->
    <aside class="absolute left-6 top-32 w-80 z-10 flex flex-col gap-4 pointer-events-none">

        <!-- Upload Control -->
        <div class="glass-panel p-6 rounded-2xl pointer-events-auto transform transition hover:scale-105 duration-300">
            <h2 class="text-lg font-bold text-yellow-500 mb-2 border-b border-white/10 pb-2">数据源接入</h2>
            <label class="block mb-4">
                <span class="sr-only">Choose file</span>
                <input type="file" id="obj-input" accept=".obj" class="block w-full text-sm text-slate-400
                  file:mr-4 file:py-2 file:px-4
                  file:rounded-full file:border-0
                  file:text-sm file:font-semibold
                  file:bg-cyan-900/50 file:text-cyan-400
                  hover:file:bg-cyan-900/80 cursor-pointer
                " />
            </label>
            <p class="text-xs text-slate-500">支持格式: .OBJ (无需贴图)<br>系统将自动进行粒子化重构。</p>
        </div>

        <!-- AI Description Panel -->
        <div class="glass-panel p-6 rounded-2xl pointer-events-auto h-96 flex flex-col">
            <div class="flex justify-between items-center mb-3">
                <h2 class="text-lg font-bold text-cyan-400">AI 考古笔记</h2>
                <svg class="w-5 h-5 text-yellow-500 animate-spin hidden" id="ai-loading" fill="none"
                    viewBox="0 0 24 24">
                    <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                    <path class="opacity-75" fill="currentColor"
                        d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z">
                    </path>
                </svg>
            </div>
            <div id="ai-content" class="text-sm leading-relaxed text-slate-300 overflow-y-auto pr-2 h-full font-light">
                <p class="italic text-slate-500">正在等待文物数据加载...</p>
                <p class="mt-4 text-xs text-slate-600 border-l-2 border-cyan-800 pl-3">
                    操作指南：<br>
                    1. 移动手掌：旋转文物<br>
                    2. 捏合手指：缩放<br>
                    3. OK手势：确认/分析
                </p>
            </div>
        </div>
    </aside>

    <!-- UI: Camera & Interaction Feedback -->
    <div
        class="absolute bottom-6 right-6 w-64 h-48 z-10 glass-panel rounded-xl overflow-hidden pointer-events-auto shadow-2xl shadow-cyan-900/20">
        <video id="input-video"
            class="absolute inset-0 w-full h-full object-cover transform -scale-x-100 opacity-60 mix-blend-screen"></video>
        <canvas id="output-canvas" class="absolute inset-0 w-full h-full transform -scale-x-100"></canvas>

        <!-- Status Overlay -->
        <div class="absolute bottom-2 left-2 right-2 flex justify-between items-end">
            <span id="gesture-label"
                class="text-xs font-bold bg-black/50 px-2 py-1 rounded text-cyan-400 tech-font">DETECTING...</span>

            <!-- SVG Progress for OK Gesture -->
            <div class="relative w-10 h-10">
                <svg class="w-full h-full" viewBox="0 0 100 100">
                    <circle class="text-gray-700 stroke-current" stroke-width="8" cx="50" cy="50" r="40"
                        fill="transparent"></circle>
                    <circle id="progress-ring" class="text-yellow-500 progress-ring__circle stroke-current"
                        stroke-width="8" stroke-linecap="round" cx="50" cy="50" r="40" fill="transparent"
                        stroke-dasharray="251.2" stroke-dashoffset="251.2"></circle>
                </svg>
                <div class="absolute inset-0 flex items-center justify-center">
                    <span class="text-[10px] font-bold text-white">OK</span>
                </div>
            </div>
        </div>
    </div>

    <!-- Loading Screen -->
    <div id="loading-overlay" class="fixed inset-0 bg-black z-50 flex flex-col items-center justify-center text-center">
        <div class="w-16 h-16 border-4 border-cyan-900 border-t-yellow-500 rounded-full animate-spin mb-4"></div>
        <h2 class="text-xl text-cyan-500 tracking-widest tech-font">INITIALIZING SYSTEM</h2>
        <p class="text-sm text-slate-500 mt-2">Connecting to Neural Interface...</p>
    </div>

    <!-- Scripts -->
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { OBJLoader } from 'three/addons/loaders/OBJLoader.js';
        import { MeshSurfaceSampler } from 'three/addons/math/MeshSurfaceSampler.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';

        // --- Global Config ---
        const CONFIG = {
            particleCount: 150000, // Reduced slightly for better stability on average GPUs
            bg: 0x000406,
            colors: {
                cyan: new THREE.Color('#06b6d4'),
                gold: new THREE.Color('#fbbf24'),
                dark: new THREE.Color('#000000')
            },
            cameraZ: 150
        };

        // --- Gemini API Setup ---
        const apiKey = ""; // Provided by runtime environment

        async function getArtifactDescription(filename) {
            if (!apiKey) {
                return "Gemini API key is missing. Simulation mode active.";
            }

            const prompt = `
            你是一位研究古蜀文明与三星堆的资深考古学家。
            用户正在查看一个名为 "${filename}" 的3D数字文物。
            请用博学、诗意且神秘的语言，写一段简短的解说词（150字以内）。
            结合"祭祀"、"神权"、"青铜时代"、"纵目"等元素。
            风格要深邃，仿佛跨越三千年的对话。
            不要包含Markdown格式，直接输出纯文本。
            `;

            try {
                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        contents: [{ parts: [{ text: prompt }] }]
                    })
                });

                const data = await response.json();
                return data.candidates[0].content.parts[0].text;
            } catch (error) {
                console.error("Gemini Error:", error);
                return "数据连接中断。无法检索古蜀文明数据库。请检查网络连接或API配置。";
            }
        }

        // --- Three.js Setup ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(CONFIG.bg, 0.002);
        scene.background = new THREE.Color(CONFIG.bg);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = CONFIG.cameraZ;
        camera.position.y = 20;

        const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        container.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.5;
        controls.enableZoom = true;

        // --- Post Processing (Bloom) ---
        const renderScene = new RenderPass(scene, camera);
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0.15; // 提高閾值，減少背景泛光
        bloomPass.strength = 0.6;   // 降低強度 (原為 1.2)
        bloomPass.radius = 0.5;

        const composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        // --- Particle System (Shader) ---

        // Vertex Shader: Morphs from random noise (Chaos) to target shape (Order)
        const vertexShader = `
            uniform float uTime;
            uniform float uMorphFactor; // 0.0 = Chaos, 1.0 = Artifact
            uniform float uScale;
            
            attribute vec3 aTarget;
            attribute float aSize;
            attribute float aRandom;
            
            varying vec3 vColor;
            varying float vAlpha;

            // Simplex noise function (simplified)
            vec3 curlNoise(vec3 p) {
                return vec3(sin(p.y*0.1 + uTime), cos(p.z*0.1 + uTime*0.5), sin(p.x*0.1));
            }

            void main() {
                // Chaos state: Floating nebula
                vec3 noisePos = position + curlNoise(position + uTime * 0.2) * 20.0;
                
                // Artifact state: The loaded OBJ vertices
                vec3 targetPos = aTarget * uScale;
                
                // Add subtle floating to the artifact state too
                targetPos += curlNoise(targetPos * 2.0 + uTime * 0.1) * 0.5;

                // Interpolate
                vec3 finalPos = mix(noisePos, targetPos, uMorphFactor);

                // Rotate based on time for the chaos part only? No, global rotation handles main view
                
                vec4 mvPosition = modelViewMatrix * vec4(finalPos, 1.0);
                gl_Position = projectionMatrix * mvPosition;

                // Size attenuation
                gl_PointSize = (aSize * 2.0 + (1.0 - uMorphFactor) * 3.0) * (300.0 / -mvPosition.z);

                // Color logic
                // Chaos = Cyan/Blue, Artifact = Gold/Bronze
                vec3 colorChaos = vec3(0.0, 0.8, 1.0); // Cyan
                vec3 colorArtifact = vec3(1.0, 0.7, 0.1); // Gold
                
                // Gradient based on Y position for depth
                float heightMix = smoothstep(-20.0, 20.0, finalPos.y);
                vec3 mixedColor = mix(colorChaos, colorArtifact, uMorphFactor);
                mixedColor = mix(mixedColor, vec3(0.0, 1.0, 0.8), heightMix * 0.3); // Add gradients

                vColor = mixedColor;
                vAlpha = 0.3 + uMorphFactor * 0.4; // 降低基礎透明度 (原為 0.6)
            }
        `;

        const fragmentShader = `
            varying vec3 vColor;
            varying float vAlpha;

            void main() {
                // Circular particle
                vec2 xy = gl_PointCoord.xy - vec2(0.5);
                float ll = length(xy);
                if(ll > 0.5) discard;

                // Soft edge
                float strength = 1.0 - (ll * 2.0);
                strength = pow(strength, 1.5);

                gl_FragColor = vec4(vColor, vAlpha * strength);
            }
        `;

        // Initialize Geometry
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(CONFIG.particleCount * 3);
        const targets = new Float32Array(CONFIG.particleCount * 3);
        const sizes = new Float32Array(CONFIG.particleCount);
        const randoms = new Float32Array(CONFIG.particleCount);

        for (let i = 0; i < CONFIG.particleCount; i++) {
            // Initial Chaos positions (Sphere cloud)
            const r = 80 * Math.cbrt(Math.random());
            const theta = Math.random() * 2 * Math.PI;
            const phi = Math.acos(2 * Math.random() - 1);

            positions[i * 3] = r * Math.sin(phi) * Math.cos(theta);
            positions[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta);
            positions[i * 3 + 2] = r * Math.cos(phi);

            // Default Target: A Torus Knot shape as a placeholder
            // We'll calculate this properly later, but init with chaos
            targets[i * 3] = positions[i * 3];
            targets[i * 3 + 1] = positions[i * 3 + 1];
            targets[i * 3 + 2] = positions[i * 3 + 2];

            sizes[i] = Math.random();
            randoms[i] = Math.random();
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('aTarget', new THREE.BufferAttribute(targets, 3));
        geometry.setAttribute('aSize', new THREE.BufferAttribute(sizes, 1));
        geometry.setAttribute('aRandom', new THREE.BufferAttribute(randoms, 1));

        const material = new THREE.ShaderMaterial({
            uniforms: {
                uTime: { value: 0 },
                uMorphFactor: { value: 0.0 },
                uScale: { value: 1.0 }
            },
            vertexShader: vertexShader,
            fragmentShader: fragmentShader,
            transparent: true,
            depthWrite: false,
            blending: THREE.AdditiveBlending
        });

        const particleSystem = new THREE.Points(geometry, material);
        scene.add(particleSystem);

        // --- Logic: Load Default Shape ---
        function generateTorusKnotPoints() {
            const tempGeo = new THREE.TorusKnotGeometry(20, 6, 150, 20);
            const sampler = new MeshSurfaceSampler(new THREE.Mesh(tempGeo)).build();
            const tempPos = new THREE.Vector3();
            const targetAttr = geometry.attributes.aTarget;

            for (let i = 0; i < CONFIG.particleCount; i++) {
                sampler.sample(tempPos);
                targetAttr.setXYZ(i, tempPos.x, tempPos.y, tempPos.z);
            }
            targetAttr.needsUpdate = true;

            // Animate morph
            animateMorph(1.0);
            updateAIDescription("未知神器 (Torus Knot Protocol)");
        }

        // --- Logic: OBJ Loading ---
        const objLoader = new OBJLoader();
        const objInput = document.getElementById('obj-input');

        objInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function (evt) {
                const contents = evt.target.result;
                const object = objLoader.parse(contents);

                // Process Mesh
                let mesh = null;
                object.traverse((child) => {
                    if (child.isMesh && !mesh) mesh = child;
                });

                if (mesh) {
                    processMeshToParticles(mesh);
                    updateAIDescription(file.name);
                }
            };
            reader.readAsText(file);
        });

        function processMeshToParticles(mesh) {
            // Reset Morph to 0 (Chaos) briefly
            material.uniforms.uMorphFactor.value = 0;

            // 1. Center and Normalize Scale
            mesh.geometry.computeBoundingBox();
            const center = new THREE.Vector3();
            mesh.geometry.boundingBox.getCenter(center);
            mesh.geometry.translate(-center.x, -center.y, -center.z);

            const size = new THREE.Vector3();
            mesh.geometry.boundingBox.getSize(size);
            const maxDim = Math.max(size.x, size.y, size.z);
            const scaleFactor = 40.0 / maxDim;
            mesh.geometry.scale(scaleFactor, scaleFactor, scaleFactor);

            // 2. Sample Points
            const sampler = new MeshSurfaceSampler(mesh).build();
            const tempPos = new THREE.Vector3();
            const targetAttr = geometry.attributes.aTarget;

            for (let i = 0; i < CONFIG.particleCount; i++) {
                sampler.sample(tempPos);
                targetAttr.setXYZ(i, tempPos.x, tempPos.y, tempPos.z);
            }
            targetAttr.needsUpdate = true;

            // 3. Animate Morph
            setTimeout(() => {
                animateMorph(1.0);
            }, 500);
        }

        function animateMorph(targetValue) {
            const start = material.uniforms.uMorphFactor.value;
            const duration = 2000;
            const startTime = performance.now();

            function update() {
                const elapsed = performance.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                // Ease out cubic
                const ease = 1 - Math.pow(1 - progress, 3);

                material.uniforms.uMorphFactor.value = start + (targetValue - start) * ease;

                if (progress < 1) requestAnimationFrame(update);
            }
            update();
        }

        async function updateAIDescription(name) {
            const aiContent = document.getElementById('ai-content');
            const loading = document.getElementById('ai-loading');

            loading.classList.remove('hidden');
            aiContent.innerHTML = `<p class="italic text-slate-500">正在分析文物结构数据 [${name}]...</p>`;

            const desc = await getArtifactDescription(name);

            // Typewriter effect
            aiContent.innerHTML = '';
            loading.classList.add('hidden');

            let i = 0;
            const speed = 30;
            function typeWriter() {
                if (i < desc.length) {
                    aiContent.innerHTML += desc.charAt(i);
                    i++;
                    setTimeout(typeWriter, speed);
                    // Scroll to bottom
                    aiContent.scrollTop = aiContent.scrollHeight;
                }
            }
            typeWriter();
        }

        // --- MediaPipe Hands Logic ---
        const videoElement = document.getElementById('input-video');
        const canvasElement = document.getElementById('output-canvas');
        const canvasCtx = canvasElement.getContext('2d');
        const gestureLabel = document.getElementById('gesture-label');
        const progressRing = document.getElementById('progress-ring');

        // Progress Ring Calc
        const radius = progressRing.r.baseVal.value;
        const circumference = radius * 2 * Math.PI;
        progressRing.style.strokeDasharray = `${circumference} ${circumference}`;
        progressRing.style.strokeDashoffset = circumference;

        let okGestureStartTime = 0;
        const OK_HOLD_TIME = 1500; // 1.5s
        let isHoldingOk = false;

        function onResults(results) {
            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);

            let detectedGesture = "NONE";

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];

                // Draw skeleton
                drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, { color: '#06b6d4', lineWidth: 2 });
                drawLandmarks(canvasCtx, landmarks, { color: '#fbbf24', lineWidth: 1, radius: 3 });

                // --- Interaction Logic ---

                // 1. Rotation (Palm center x)
                // Landmarks 0 (wrist) and 9 (middle finger mcp) avg
                const palmX = landmarks[0].x; // 0-1, left to right (mirrored view)
                // Map 0-1 to -PI to PI
                const targetRotation = (palmX - 0.5) * 4.0;
                // Smoothly update rotation
                particleSystem.rotation.y += (targetRotation - particleSystem.rotation.y) * 0.05;

                // 2. Pinch to Scale (Thumb Tip 4, Index Tip 8)
                const thumbTip = landmarks[4];
                const indexTip = landmarks[8];
                const distance = Math.sqrt(
                    Math.pow(thumbTip.x - indexTip.x, 2) +
                    Math.pow(thumbTip.y - indexTip.y, 2)
                );

                // Distance usually 0.05 (closed) to 0.3 (open)
                // Map to scale 0.5 to 2.0
                if (distance > 0.05) {
                    const targetScale = 0.5 + (distance * 4.0);
                    const currentScale = material.uniforms.uScale.value;
                    material.uniforms.uScale.value += (targetScale - currentScale) * 0.1;
                }

                // 3. OK Gesture Detection
                // Thumb and Index close, others extended
                const middleTip = landmarks[12];
                const ringTip = landmarks[16];
                const pinkyTip = landmarks[20];
                const wrist = landmarks[0];

                const isPinch = distance < 0.08;
                const isExtended = (y) => wrist.y - y > 0.1; // Simple check: tips above wrist significantly

                // In canvas coords, y is 0 at top. Higher hand = lower y value.
                // Distance from wrist to tip
                const distWristMiddle = Math.sqrt(Math.pow(wrist.x - middleTip.x, 2) + Math.pow(wrist.y - middleTip.y, 2));

                if (isPinch && distWristMiddle > 0.15) {
                    detectedGesture = "OK DETECTED";
                    if (!isHoldingOk) {
                        isHoldingOk = true;
                        okGestureStartTime = performance.now();
                    } else {
                        // Update Progress Ring
                        const elapsed = performance.now() - okGestureStartTime;
                        const progress = Math.min(elapsed / OK_HOLD_TIME, 1);
                        const offset = circumference - progress * circumference;
                        progressRing.style.strokeDashoffset = offset;

                        if (elapsed >= OK_HOLD_TIME) {
                            detectedGesture = "CONFIRMED";
                            triggerOkAction();
                            okGestureStartTime = performance.now(); // Reset to prevent spam
                        }
                    }
                } else {
                    isHoldingOk = false;
                    progressRing.style.strokeDashoffset = circumference;
                }
            } else {
                // Auto rotate if no hand
                particleSystem.rotation.y += 0.002;
            }

            gestureLabel.innerText = detectedGesture;
            canvasCtx.restore();
        }

        function triggerOkAction() {
            // Visual feedback
            material.uniforms.uMorphFactor.value = 0.5; // Brief flash to chaos
            setTimeout(() => {
                animateMorph(1.0);
            }, 300);

            // Re-generate description for current item as a "Refined Scan"
            updateAIDescription("深度扫描 - 重新校准");
        }

        const hands = new Hands({
            locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
            }
        });

        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults(onResults);

        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({ image: videoElement });
            },
            width: 320,
            height: 240
        });
        cameraUtils.start();

        // --- Window Resize ---
        window.addEventListener('resize', onWindowResize, false);
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
            material.uniforms.uResolution?.value.set(window.innerWidth, window.innerHeight);
        }

        // --- Animation Loop ---
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);

            const elapsedTime = clock.getElapsedTime();
            material.uniforms.uTime.value = elapsedTime;

            controls.update(); // only needed if autoRotate or damping

            // Render Bloom
            composer.render();
        }

        // --- Init ---
        // Hide loading screen after 1.5s
        setTimeout(() => {
            document.getElementById('loading-overlay').style.opacity = '0';
            setTimeout(() => {
                document.getElementById('loading-overlay').style.display = 'none';
                generateTorusKnotPoints(); // Start with default
            }, 500);
        }, 1500);

        animate();

    </script>
</body>

</html>